---
title: "Notas de R"
author: "Roberto Álvarez"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: book.bib
biblio-style: apalike
link-citations: yes
github-repo: rstudio/bookdown-demo
description: "Estas son las notas de un curso básico de R."
output_dir: docs
---
# Notas de R básico


<!--chapter:end:index.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Introducción a R {#intro}
R es un entorno integrado para el manejo de datos, el cálculo, la generación de gráficos y análisis estadísticos. Las principales ventajas del uso de R son:

1. Software libre.
2. Facilidad para el manejo y almacenamiento de datos.
3. Un conjunto de operadores para el cálculo de vectores y matrices.
4. Una colección extensa e integrada de herramientas intermedias para el análisis estadístico de datos.
5. Multitud de facilidades gráficas de altísima calidad.
6. Un lenguaje de programación (muy) poderoso con muchas librerías especializadas disponibles.
7. La mejor herramienta para trabajar con datos genómicos, proteómicos, redes, metabolómica, entre varias más.
8. **Casi todos podemos aprender por nuestra cuenta a usar excel (pero hay que pagar por la licencia, es software privativo...). Sin embargo, es más  díficil aprender por nuestra cuenta R; y si lo hacemos nos da una ventaja comparativa sobre el resto.** 
9. Además excel no es la mejor elección si queremos hacer bioinformática en serio. 


## Introducción a R para Estudiantes de Microbiología

R es un lenguaje de programación y un entorno de desarrollo estadístico ampliamente utilizado en la comunidad científica, incluida la microbiología. Este poderoso recurso ofrece una variedad de ventajas y funcionalidades que pueden beneficiar significativamente a los estudiantes de microbiología en su investigación y análisis de datos.

### Ventajas de Aprender R para Estudiantes de Microbiología

1. Análisis Estadístico Avanzado

R proporciona una amplia gama de paquetes y herramientas estadísticas que permiten a los estudiantes de microbiología realizar análisis avanzados de datos, desde pruebas de hipótesis básicas hasta modelos de regresión y análisis multivariados.

2. Visualización de Datos

Con paquetes como ggplot2, los estudiantes pueden crear visualizaciones de datos interactivas y de alta calidad que facilitan la comprensión de patrones y tendencias en conjuntos de datos microbiológicos, como datos de secuenciación genómica o datos de conteo de microorganismos.

3. Reproducibilidad y Documentación

RMarkdown es una herramienta poderosa que permite a los estudiantes escribir documentos reproducibles que combinan código, resultados y narrativa en un solo lugar. Esto promueve la transparencia, la reproducibilidad y una mejor documentación de los análisis microbiológicos.

4. Acceso a una Comunidad Activa

R cuenta con una comunidad activa de usuarios y desarrolladores que comparten código, paquetes y recursos educativos. Los estudiantes pueden aprovechar este recurso para buscar ayuda, colaborar en proyectos y mantenerse al tanto de las últimas tendencias en análisis de datos microbiológicos.

5. Flexibilidad y Personalización

R es un lenguaje altamente flexible que permite a los estudiantes adaptar sus análisis a las necesidades específicas de sus proyectos microbiológicos. Desde la manipulación de datos hasta la creación de modelos personalizados, R ofrece la libertad y la capacidad de personalización necesarias para abordar una amplia variedad de preguntas de investigación en microbiología.

Aprender R puede ser extremadamente beneficioso para los estudiantes de microbiología al proporcionarles las herramientas y habilidades necesarias para realizar análisis de datos sofisticados, visualizar resultados de manera efectiva y promover la reproducibilidad en su investigación científica.





## Paquetes o bibliotecas

Las funciones especializadas de R se guardan en paquetes *(packages)* que deben ser invocados ANTES de  llamar a una función del paquete.


Una manera de instalar paquetes es mediante el repositorio [CRAN](https://cran.r-project.org/). 

Navega por CRAN y encuentra algunos paquetes que podrían interesarte. Hay miles y cada día aumentan.

Para saber qué paquetes se tienen instalados en
tu máquina teclea la función `library()`

```{r}
library()
```


Para cargar un paquete, que se encuentre previamente instalado, se debe teclear
`library(nombre_de_paquete)`

Por ejemplo: 
```{r}
library(gplots)  
```

Para visualizar los paquetes ya cargados, teclea:

```{r}
search()
```

Para visualizar las funciones dentro de un paquete en particular se utiliza:

```{r}
ls(2)
```

 **EJEMPLOS DE VISUALIZACIÓN DE GRÁFICOS**

```{r}
demo(graphics)
```

**Ejercicios** 

1. Instala las siguientes librerías que te serviran durante todo el curso
   * markdown
   * ggplot2
   
   
   
**INFORMACIÓN ADICIONAL**

Existen repositorios adicionales a [CRAN](https://cran.r-project.org/), uno de ellos es [Bioconductor](https://https://bioconductor.org/), en él puedes buscar e instalar paquetes como `ggtree`. 

**Ejercicio**
1. Explora la página de Bioconductor, apóyate de su buscador e instala el paquete `ggtree`. 



## Ayuda en R

En la mayoría de las ocasiones desconocemos el alcance de alguna paquetería, los criterios de alguna función o en general, sabemos lo que queremos hacer pero no tenemos ni idea de qué paqueteria usar. 

Los comandos `help()` y `?` son equivalentes, ambos van a permitir encontrar información sobre paqueterias, comandos o funciones generales de R. Se debe teclear `help(nombre_comando)` o `?nombre_comando` 

Por ejemplo, para buscar información detallada del comando solve: 

```{r}
help(solve)
```

```{r}
?solve
```


Para buscar ayuda de funciones o palabra reservadas se utilizan comillas:

```{r}
help("for")
```


También existen opciones como `help.start()` y `help.search()` para obtener una versión extendida de la ayuda general desplegada en un navegador. Para ello se requiere tener la ayuda en HTML instalada y conexión a la red. 

`help.search()` es una función que escanea documentación para paquetes previamente instalados. 

Ejemplo: 
```{r}
help.search("clustering")
```


`help.start()` es una función que despliega información basada en documentos en línea de la versión actual de R, además de brindar links a manuales y la lista de las paqueterías instaladas, entre otras cosas. 

Ejemplo: 
```{r}
help.start()
```


Cuando queremos ver ejemplos del uso de los comandos usamos la función `example()` 

Ejemplo: 
```{r}
example("hclust")
```


 Todo lo anterior requiere que conozcamos el nombre correcto del comando, pero ¿qué pasa si no lo sabemos?, ¿lloramos? no. 
 Podemos utilizar el comando `apropos()` para encontrar todo lo relacionado con algún término. 
 
 Ejemplo: 
```{r}
apropos("solve")
```

Ahora, ¿qué pasa cuando tengo la idea de lo que quiero hacer pero no se qué paqueteria usar, ni cuál comando? puedo usar `??` seguido de una palabra clave. Esto nos arrojará sugerencias sobre lo que deseamos hacer. 

 Ejemplo: 
```{r}
??DNA
```

**NOTA** Se recomienda el uso del autocompletado, de esta manera reducirás errores de dedo. 

## Expresiones y asignaciones

Las **expresiones** y **asignaciones** son los dos tipos de resultados que arroja R. 

Las **expresiones** sólo se muestran en la salida estándar y NO se guardan en alguna variable, es decir, cada que se corra la línea se obtendran valores distintos. 

Ejemplo: 
```{r}
rnorm(10)
```

```{r}
rnorm(10)
``` 


Las **asignaciones**, como su nombre lo indica, se guardan los valores al ser asignados a una variable. Esto se puede lograr mediante el uso de `<-` 

Ejemplo: 
```{r}
x <- rnorm(10)
```

```{r}
x
```

**NOTA** El símbolo `<-` es equivalente en función a `=` pero puede llevar a confusiones importantes con el operador `==`. 

![Operador de asignación. Así que evita el uso del igual](equals-sign-assignment-operator-imgflip-com-going-through-data-structures-and-47188178.png)


Otro punto a considerar respecto a las **asiganciones** es que R es capaz de distinguir entre mayúsculas y minúsculas, por lo que la misma letra puede contener valores distintos. 

Ejemplo: 
```{r}
a <- 3
A <- 6
```

```{r}
a
```

```{r}
A
```

Una opción es definirlas en más de una línea, ejemplo:
 
```{r}
a <-
  pi + 12
```

**NOTA** Ten mucha precaución con el nombre que asignas a un valor, ya que podrías sobreescribirlo y se le quedará asignado el último valor. 

Ejemplo: 
```{r}
b <- 3
b

b <- 8 
b
```


La separación de comandos puede darse de dos formas: 

Empleando `;`, ejemplo:  

```{r}
a <- 3; b <-5
```
 
o usando un salto de línea, esta es una mejor opción, ejemplo: 

```{r}
a <- 3
b <-5
```


## Movimiento entre directorios
Otra de las ventajas que ofrece R es que permite ubicar algún archivo o saber la dirección del directorio en la que nos encontramos actualmente, todo ello sin necesidad de salir de la interfaz. 

Para saber en qué directorio estamos, se teclea:  

```{r}
getwd()
```

Para cambiar de directorio utilizamos `setwd("direccion_a_la_que_quieres_ir")` 

                              
```{r}
setwd("~")
```

##Bash en R 
También se pueden usar los comandos de la terminal de bash dentro de R, utilizando la función `system()`


Para listar archivos de una carpeta usamos `ls`
```{r}
system("ls -la")
```


Para saber en qué directorio estamos usamos la función análoga a `getwd()`, que es `pwd`
```{r}
system("pwd")
```

**Importante: Como regla general todos los nombres van entre comillas: nombre de carpetas, archivos, de columnas, de renglones,etc.**


## Operaciones aritméticas
R también puede ser usado como calculadora. 
Se puede sumar, restar, multiplicar,dividir, "exponenciar" y calcular la raíz cuadrada.

**SUMA** con el operador `+`

```{r}
a + b
```

**RESTA** con el operador `-`

```{r}
a - b
```

**MULTIPLICACIÓN** con el operador `*`

```{r}
a * b
```

**DIVISIÓN** con el operador `/`

```{r}
a / b
```

**EXPONENTE** con los operadoradores `**` o `^`

```{r}
a ** b
```

```{r}
a ^ b
```

**RAÍZ CUADRADA** con la función `sqrt()`

```{r}
sqrt(a)
```

**LOGARITMO** con la función `log()`

```{r}
log(a)
```

### Prioridad en las operaciones

Las operaciones se efectuan en el siguiente orden:

1. izquierda a derecha
2. `sqrt()` y `**` `^`
3. `*` y  `/`
4. `+` y `-`
5. `<-`

*IMPORTANTE* Este orden se altera si se presenta un paréntesis. En ese caso la operación dentro del paréntesis es la que se realiza primero.

Ejemplos: 

`4 + 2 * 3 = 4 + 6 = 10`

`4 - 15/3 + 3^2 + sqrt(9) = 4 - 15/3 + 9 + 3 = 4 - 5 + 12 = 13`

`4 - (3+7)^2 + (2+3)/5 = 4 - (10)^2 + 5/5 = 4 - 100 + 1 = -95`


**Ejercicios**

Resuelve en un pedazo de papel primero para saber cuál sería el resultado de las siguientes operaciones aritméticas. Después comprueba tu resultado tecleandolas en R. 


1. 1 + 2*3 + 3 + 15/3
2. 4 - 15/3 + 3^2 + 3*sqrt(81)
3. 40 - (4+3)^2 + (10-5)/3
4. 32^5 - (3-5)*2 + 32/sqrt(64) 
5. 1/(3^-3) + (8-10^2) - (25/sqrt(25))^2

## Tipos de valores en R 

### Valores booleanos

También conocidos como *Datos lógicos*. 
Este tipo de datos **sólo** contienen información `TRUE` o `FALSE`, lo cual sirve para evaluar si los elementos de un vector cumplen con los criterios deseados. Para ello se utilizan los operadores de comparación: 

- igual `==` 
- no es igual a `!=`
- menor que `<`
- mayor que `>`
- menor o igual que `<=`
- mayor o igual que `>=`

Ejemplo: 
```{r}
1 < 5
10 == 0    
10 != 0   
10 <= 0   
```

**NOTA** Dentro de R los valores lógicos `TRUE` y `FALSE` tienen un valor numérico. `TRUE`equivale a 1 y `FALSE` es equivalente a 0. Esto permite cuantificar el número de elementos que cumplen con los criterios, ¿cómo? mediante la suma de los `TRUE`s. 


**Ejercicios** 
Demuestra si: 
1. El logaritmo base 10 de 20 es menor que la raíz cuadrada de 4. Desarrollalo en una sola línea. 
2. 1/3^-1 es igual a 3/1^-1
3. (-2)^2 no es igual a (2)^2

### Caracter

Son *strings* de texto y se caracterizan porque cada uno de los elementos va entre comillas. Los elementos pueden ser desde sólo un caracter hasta oraciones.
Podría parecer que la variable a la cual lo asignamos contiene números, pero las comillas indican que serán tratados como texto. Podemos subsetearlos por su índice o buscando literalmente el texto.

Ejemplo: 
```{r}
x<- "La candente mañana de febrero en que Beatriz Viterbo murió, después de una imperiosa agonía que no se rebajó un solo instante ni al sentimentalismo ni al miedo"
```


### Enteros y números (numeric)

Existen dos formas diferentes en que las computadoras pueden guardar los números y hacer operaciones matemáticas con ellos: `numeric` e `integer`. 
Por lo común no importa esta diferencia, pero puede ser relevante para algunas funciones de Bioconductor. En R se representan los números como `numeric` y el tamaño máximo que maneja para un `integer` es ligeramente más chico que el tamaño del genoma humano. 

¿Cómo revisar si un objeto es numeric o entero? Con la función `class()` 

```{r}
x <- 1
class(x)
x <- 1:3
class(x)
```

<!--chapter:end:01-Intro.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---

# Vectores {#estructura} 

R permite manejar datos dentro de estructuras para poder trabajarlos, estas estructuras pueden ser: 
- Vector: Es de una sola dimensión y solo permite almacenar datos del mismo tipo. 
- Matriz: Es un arreglo en dos dimensiones y permite ingresar datos del mismo tipo. 
- Data Frame: Similar a la matriz por ser también de dos dimensiones, solo que este arreglo permite distintas clases de datos. 
- Lista: Es de una sola dimensión como el vector, la diferencia que es que una lista permite incorporar diferentes tipos de datos. 

## Contenido 

Para conocer el contenido de una variable, sólo es necesario poner la variable y presionar *enter*  (sesión interactiva). En el caso de estar en un *script* es necesario usar la función `print()`

Ejemplo: 
```{r}
x<-3
print(x)
```

## Vectores en R {#vectors} 

Un *vector* es una colección de datos del mismo tipo, siempre del **mismo tipo**, no es posible mezclarlos. Los elementos contenidos dentro de un vector son conocidos como *componentes* y pueden ser del tipo lógico, caracteres, numéricos o integer.

## Definición
Para definir un vector se utiliza la función `c()`, que significa *combine*. 
Existen dos formas de definir un vector: **Extensiva** y **Secuencia**. 

### Definición extensiva 
La **forma extensiva** para definir un vector considera que los elementos situados dentro del paréntesis tienen que estar separados por comas. 

Ejemplo: 
```{r}
vector_numerico <- c(1, 3, 5, 7)      # vector numérico
vector_texto <- c("a", "b", "c", "d") # vector de texto
vector_logico <- c(TRUE, FALSE, TRUE) # vector lógico / booleano
```

### Definición en secuencia 

#### Uso de c() 
En algunas ocasiones definir de manera extensiva puede resultar muy poco eficiente, sobre todo para vectores que contengan una gran cantidad de elementos en secuencia, para ello se definen en **forma de secuencia** empleando el operador `:`. 

Ejemplo: 
Un vector que tenga los primeros 100 números enteros
```{r}
x <- c(1:100)

x
```

#### Uso de seq() 

Otra alternativa es la función `seq()` que significa *sequence* y es una generalización del operador `:`. 

Ejemplo: 
```{r}
x <- seq(1,100)

x
```


Esta función permite generar secuencias numéricas de distintas clase y por diferentes rangos. 

Ejemplo:
Una secuencia que vaya desde -12 hasta 30 en un rango de 3, es decir, -12, -9, -6, ..., 27, 30: 
```{r}
x <- seq(from=-12,to=30,by=3)

x
```


**NOTA** Se puede omitir *from*, *to* y *by* mientras se sigan colocando los valores en el mismo orden.

Ejemplo: 
```{r}
y <- seq(0,1,0.1)

y
```

**NOTA** Si queremos cambiar el orden, debemos necesariamente ponerlos. 
Ejemplo:
```{r}
z <- seq(by=0.1, to =1, from=0.5)

z
```

## Longitud de un vector

La *longitud* de un vector se refiere al número de elementos que contiene. Para conocer ese dato se emplea la función `length()`

Ejemplo: 
```{r}
s <- (1:5)

length(s)
```


## Elementos de un vector

Para acceder a elementos de un objeto con *indices* (componentes que tienen una posición asignada), debemos usar *corchetes* `[]`. Los corchetes pueden contener posiciones consecutivas o no consecutivas. 

### Elementos consecutivos
Se definen el rango de las posiciones a seleccionar, para ello se emplea el operador `:`

Ejemplo: 
```{r}
#Se define el vector con la variable "x"
x <- c("Muchos", "años" ,"después" ,",", "frente", "al" ,"pelotón")

#Elegir desde el primer hasta el cuarto elemento del objeto "x"
x[1:4]
```

Ejemplo: 
```{r}
x <- c(1,2,3,5,8,13,21)

x[3:6]
```



### Elementos no consecutivos de un vector
Las posiciones a seleccionar se colocan en un vector separadas por `,`, a su vez este vector se coloca dentro de los corchetes.


Ejemplo:
```{r}
#Se define el vector "x"
x <- c("Hola", "Bien", "cómo", "!", "estás", ":(", "?")

#Se indica dentro de un nuevo vector que se seleccionen las posiciones 1, 3, 5 y 7 del vector "x". 
x[c(1,3,5,7)]

```

NOTA: No es necesario que estén en orden

Ejemplo: 
```{r}

x<-c(1,2,3,5,8,13,21)

x[c(2, 7, 4)]
```



### Excluir elementos de un vector

Para omitir algun o un conjunto de elementos de un vector, se emplea el signo menos dentro de los corchetes `[- ]`

Ejemplo: 
```{r}
#Se define el vector "x"
x <- c(1,2,3,5,8,13,21)

#Dentro del corchete indicamos la posición que se quiere omitir 
x[-4]

#Cuando se quiere omitir un conjunto de elementos, se definen las posiciones dentro de un vector
x[-c(2, 7, 4)]   # Todos menos el segundo , séptimo y cuarto elemento
```

¿Esto qué hace? 
```{r}

x[-length(x)]

```

*NOTA* Este comando  `[- ]` **no elimina** elementos de un vector sólo los selecciona y omite. Sin embargo, el vector original continua intacto. 

```{r}
x <- c(1,2,3,5,8,13,21)
x[-6] 
x     # Estoy intacto
```

## Reasignar elementos de un vector

Se pueden asignar nuevas posiciones y valores a un vector previamiente definido 

Ejemplo: 

```{r}
#Se define el vector "x"
x <- c(88,5,12,13)

#Agregamos el valor "168" en la posición 4. Intenta explicar paso a paso la siguiente línea de comando. 
x <- c(x[1:3],168,x[4]) 
x
```

Se puede definir un vector vacío y luego "llenarlo" asigando una posición a los componentes. 

```{r}
x<-c()
x                 # Soy un vector vacío :(
x[1]<- 2
x[2:5]<-c(56,78,90,12)
x                 # Ahora ya no :)
```

## Repetición de elementos de un vector

La función `rep()`, que viene del inglés *repeat*, nos permite repetir elementos en un vector dado. 
El comando `rep()` sigue el siguiente formato `rep(valor, n veces)`.

Ejemplo: 
```{r}
#Repite 5 veces el valor "3" y asignalo a la variable "x"
x <- rep(3,5)
x

#También se pueden repetir un conjunto de valores una vez que sean colocados dentro de un vector
y <- rep(c(1,2,3,5),3) #Repite 3 veces los valores 1, 2, 3 y 5. 
y
```
Ejemplo: 
```{r}
primos <- c(1,2,3,5,7,11)
z <- rep(primos,4)
z
```


Dentro del comando `rep()` se encuentra la opción `each`, la cual permite  definir la frecuencia de repetición.

Ejemplo: 
```{r}
x<-c(1,2,3,4)

y<-rep(x,each=2)
y
```

## Uso de funciones `any()` y `all()`

Las funciones `any()` *algún* y `all()` *todos* permiten conocer si alguno o todos los elementos de un vector cumplen cierta condición.
El resultado obtenido siempre será un valor booleano:  **TRUE** o **FALSE**

Ejemplo: 
```{r}
x <- 1:15
any(x > 7.5)
```

```{r}
any(x > 19.76)
any(x >= 15)
```


```{r}
all(x > sqrt(100))
```

```{r}
all(x>0)
```

**Ejercicios**

1. Dado un vector x, escribe un código que determine si todos los elementos del vector son iguales a cero utilizando la función all().
2. Escribe un código que tome un vector x y devuelva TRUE si hay algún elemento repetido en el vector, utilizando la función any().
3. Dado un vector x, escribe una función que determine si todos los elementos del vector son iguales entre sí utilizando la función all().
4. Escribe una función que tome dos vectores ("x" y "y") y devuelva TRUE si ambos vectores tienen algún elemento en común, utilizando la función any().
5. Escribe una función que tome dos vectores ("x" y "y") y devuelva TRUE si todos los elementos del vector x son mayores que los elementos correspondientes en el vector y, utilizando la función all().
6. Dado un vector x, escribe una función que determine si todos los elementos del vector son menores que cero utilizando la función all().
7. Escribe una función que tome dos vectores ("x" y "y") y devuelva TRUE si al menos un elemento del vector x es mayor que los elementos correspondientes en el vector y, utilizando la función any().
8. Dado un vector x, escribe una función que determine si todos los elementos del vector son iguales a un valor específico a utilizando la función all().
9. Escribe una función que tome dos vectores ("x" y "y") y devuelva TRUE si al menos un elemento del vector x es menor que los elementos correspondientes en el vector y, utilizando la función any().


## Operaciones con vectores

### Operaciones aritméticas 
Al igual que en álgebra podemos definir varias operaciones que nos dejan siempre otro vector. Las operaciones se pueden realizar vector/vector o vector/escalar. 

Se definen los vectores
```{r}
x<-c(1,2,3)
y<-c(4,5,6)
```

**SUMA** con el operador `+`

```{r}
x + y 
x + 2
```

**RESTA** con el operador `-`

```{r}
x - y
x - 1
```

**MULTIPLICACIÓN** con el operador `*`

```{r}
x * x
x * y 
y * 3 
```

**DIVISIÓN** con el operador `/`

```{r}
x / y
y / 5
```

**EXPONENTE** con los operadoradores `**` o `^`

```{r}
x ** y
y ^ 2
```

**RAÍZ CUADRADA** con la función `sqrt()`

```{r}
sqrt(y)
```

**LOGARITMO** con la función `log()`

```{r}
log(x)
```

*NOTA* CUIDADO con el tamaño de los vectores al momento de realizar operaciones entre ellos. 

## Operaciones con un comando 

También podemos aplicar funciones para calcular con una sola instrucción varias operaciones útiles, esto nos ahorra tiempo. 

**Ejercicio** Calcula el promedio de los números del 1 al 10. 

```{r}
#Respuesta muy larga 
(1+2+3+4+5+6+7+8+9+10)/10

```
*Okaaaay, no es un proceso taaaaan largo pero ¿qué pasa cuando queremos calcular el promedio de 10,000 números? RIP* para ello se pueden emplear los siguientes comandos `min()`, `max()`, `range()`, `sum()`, `mean()`, `median()`, `sd()`,`quantile()`,`unique()`,`sort()`

```{r}
#Se define el vector que incluye mil datos
x<-rnorm(1000)

min(x) #Se obtiene el valor mínimo
max(x) #Se obtiene el valor máximo
range(x) #Da a conocer el rango en el cual se encuentran los valores, es decir el valor min y max. 
sum(x) #Realiza la suma de todos los valores contenidos en el vector 
mean(x) #Calcula el promedio del conjunto de valores 
median(x) #Se obtiene la mediana 

```
**Ejercicio** ¿Qué función tienen los siguientes comandos `sd()` y `quantile()`?

Para `unique()` y `sort()` conviene tener elementos discretos más que continuos. 
 
```{r}
x <- c(rep(3,5),1:15,rep(c(1,2,3),5))
unique(x)
```
 
 
```{r}
x <- sample(10,10)
x
sort(x)
```
 
## Gráficos con vectores

Podemos graficar los vectores de manera inmediata en `R`

```{r}
x<- rnorm(10000)

hist(x,col="tomato2") #Histograma: grafica la distribución de las frecuencias de los datos 
plot(x,col="salmon") #Gráfica los datos en el orden de aparición en el vector 
boxplot(x,col="wheat") #Boxplot: muestra la mediana y quantiles
```


## Vectores con nombre
Una de las cracterísticas de R es que se puede asignar nombres a los vectores, para ello usamos la función `names()`

Ejemplo: 
```{r}

edades <- c(35,35,70,17,14) #Definimos un vector llamado "edades"
nombres <- c("Jerry","Beth","Rick", "Summer","Morty") #Definimos un vector llamado "edades", del mismo tamaño que "edades"

names(edades) <- nombres #Se nombran los elementos del vector "edades"
edades

```

También se selecciona de la manera usual, por ejemplo, si quiero ver cuál es la edad de Rick, debo seleccionar el elemento 3: 

```{r}
edades[3]
```

Esto es  muy poco eficiente y propenso al error, sobre todo con vectores muy grandes. Por ello podemos usar los nombres de los vectores: 

```{r}
edades["Rick"]
```
**Recuerda que los nombres S-I-E-M-P-R-E van entre comillas**

```{r}
edades[c("Rick","Morty")]
```


**Ejercicios:**

1. ¿Cuál es el promedio de las edades, sin contar el de Beth?
2. Quiten a Morty del vector, ordénenlo y guárdenlo como un nuevo objeto.
3. ¿Hay alguna edad que sea mayor de 75? ¿Menor de 12? ¿Entre 12 y 20?


### Tamaños de genomas 
Ahora veamos un ejemplo más "biológico"

```{r}
genomeSizeM_BP<-c(3234.83,2716.97,143.73,0.014281,12.1)
```

**NOTA** Si se desea ver el tamaño en bp, simplemente multiplicamos por el valor del prefijo (Mega = 1 millón)

```{r}
genomeSizeM_BP*1e6
```


```{r}
organismo<-c("Human","Mouse","Fruit Fly","Roundworm","Yeast")
```


```{r}
names(genomeSizeM_BP)<- organismo
```


```{r}
genomeSizeM_BP
```

¿Qué hay de diferente entre el primer vector al que le se asiganaron los tamaños de genomas & esta última versión? 


**RECUERDA**
Se pueden seleccionar elementos de un vector utilizando corchetes:

```{r}
genomeSizeM_BP[1]
```

Para obtener elementos consecutivos:

```{r}
genomeSizeM_BP[1:4]
```

Para obtener elementos NO consecutivos:

```{r}
genomeSizeM_BP[c(1,2,5)]
```

Para descartar (no eliminar, ni quitar) ciertos elementos: 

```{r}
genomeSizeM_BP[-c(1,3,5)]
```

Para referirnos a los elementos por el nombre asignado: 

```{r}
genomeSizeM_BP[c("Yeast","Human")]
```

Además de algunas operaciones aritméticas se pueden calcular con la media, máximo, mediana, mínimo, suma y longitud de los vectores

**Ejercicio**

1. Generar un vector de las edades de 10 de tus compañeros 
2. Asignales nombre.
3. Encuentra el mínimo,máximo, media, mediana, la desviación estándar, la longitud del vector y selecciona sólo los elementos impares.
4. Elimina el máximo y el mínimo y con el vector resultante realiza un histograma.
5. Crea un vector de caracteres con diez nombres de especies y asocialo con su número de acceso de NCBI para su genoma en nucleótidos.

## ¿Cómo lidiar con las NAs ?

Es (muy) freceunte que en bases de datos se tengan valores `NA`, es decir medidas que no pudieron realizarse, medidas perdidas, etc. Para ello se utiliza `NA`. 
`R` trata de manera especial a las NAs

```{r}
x <- c(88,NA,12,168,13)
```

Existe una fución para determinar si un elemento es o no una `NA`. La función es `is.na()`

```{r}
x <- c(88,NA,12,168,13)
```

```{r}
is.na(x)
```

Si queremos calcular ciertas funciones numéricas `R` no sabrá qué hacer

```{r}
x <- c(88,NA,12,168,13)
mean(x)
```

Sin emabrgo, podemos decirle a `R` que las omita, indicando como argumento de la función `mean()` `na.rm=TRUE` que significa *na remove*

```{r}
x <- c(88,NA,12,168,13)
mean(x,na.rm=TRUE)

```

¿Qué otras funciones tienen esta opción  `na.rm=TRUE` ?


## Filtrado de elementos de un vector

Podemos generar vectores de que sean subconjuntos de vectores más grandes que cumplan cierta(s) condición(es)

```{r}
un_vector <- c(1,2,3,5,7,11,13,17,19) 
otro_vector <- un_vector[un_vector*un_vector > 10]   #Se lee el vector desde dentro hacía afuera
otro_vector
```


Veamos paso a paso qué es lo que hace este proceso

```{r}
un_vector
un_vector*un_vector > 10    # Mira, de adentro hacía afuera
indices<-un_vector*un_vector > 10 
un_vector[indices]
un_vector[c(FALSE,FALSE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE)]
```

La representación interna de los valores booleanos `FALSE` y `TRUE`son 0 y 1, respectivamente

```{r}
un_vector[c(rep(0,3),rep(1,1))]
```

### Filtrado con `subset()`

Podemos usar la función `subset()`para hacer lo mismo que en el caso anterior **excepto que omite los NA**

```{r}
un_vector<-c(1,2,3,5,7,11,13,17,19) 
otro_vector <- subset(un_vector,un_vector*un_vector > 10)   
otro_vector
```


Qué pasa si tenemos `NA`s. Si usamos el método anterior obtendríamos

```{r}
un_vector<-c(1,2,3,5,7,11,NA,13,17,NA,19) 
otro_vector <- un_vector[un_vector*un_vector > 10]   # Leeme de adentro hacia afuera
otro_vector  # Aquí salen las NAs
```


En cambio con `subset()`

```{r}
un_vector<-c(1,2,3,5,7,11,NA, 13,17,NA, 19) 
otro_vector <- subset(un_vector,un_vector*un_vector > 10)   
otro_vector  # Aquí ya no aparecen las NAs
```


### La función de selección `which()`

La función `which()` nos regresa los índices, es decir, dice **quiénes** cumplen cierta condición


```{r}

z <- c(5,2,-3,8)
which(z*z > 8)

```

Acá nos dicen quiénes

```{r}
z[which(z*z > 8)]
```

## ¿Cómo podemos ver si dos vectores son iguales?

Dos vectores son iguales si elemento a elemento son idénticos.
Por lo tanto deben de ser del mismo tamaño.
**RECUERDA** Para probar si dos elementos son iguales se utiliza el operador de comparación `==` son dos signos iguales juntos, sin espacio.
No confundir con el operador `=` que se puede usar como operador de asiganción (aunque no es recomendable su uso. De hecho está prohibido en este curso >:(

```{r}
x <- c(1,4,9,16,25)
y <- 1:5
y <- y*y
```


```{r}
x==y
```

¿Qué pasaría si me confundo y escribo el operador de igualdad en lugar del de comparación?


```{r}
y <- 5:9
y
```

```{r}
x = y
```


```{r}
x
y
```

Para vectores grandes puedo usar la función `all()` que ya vimos arriba


```{r}
x <- seq(1,10000,1)
y <- seq(1,10000,1)
all(x==y)
```
¿Cómo podríamos corrobar que son iguales usando `any`?

También podríamos utilizar que `TRUE` es `1` y que `FALSE`  es `0`

¿Por qué este código nos dice que sí son iguales?

```{r}
sum(x==y)
```


### Factor

Los factores son un tipo de vector que puede tomar un número "limitado" de valores, que normalmente se utilizan como variables categóricas. Por ejemplo: macho/hembra. Es útil tenener este tipo de objeto porque varios modelos estadísticos que se pueden correr en `R` los utilizan. A los valores que pueden tomar los elementos del factor se les conoce como *levels*.


```{r}
x <- c(1,2,2,3,1,2,3,3,1,2,3,3,1)
x
as.factor(x)
x <-as.factor(x)
x
```


Los factores son una manera computacionalmente eficiente de almacenar caracteres, pues cada valor único (*level*) se guarda solo una vez y a los datos se les asigna un valor entero. 

```{r}
meses = c("March","April","January","November","January",
       "September","October","September","November","August",
        "January","November","November","February","May","August",
        "July","December","August","August","September","November",
         "February","April")
meses
meses <- as.factor(meses)
meses
```


El que existan los *levels* permite realizar ciertas operaciones y manipular el contenido del factor.

```{r}
table(meses)
levels(meses)
levels(meses)[1]
levels(meses)[1]<-"Abril"
levels(meses)
meses
```

### Ejercicio: Temperaturas de Incubación

Supongamos que estamos realizando un experimento de cultivo bacteriano y registramos las temperaturas de incubación para diferentes muestras. Queremos calcular la temperatura media y la desviación estándar.


```{r}
# Temperaturas de incubación (en grados Celsius)
temperaturas <- c(37, 37, 25, 30, 30, 37, 25, 25)

# Cálculo de la temperatura media
temp_media <- mean(temperaturas)
cat("Temperatura media:", temp_media, "°C\n")

# Cálculo de la desviación estándar
temp_desviacion <- sd(temperaturas)
cat("Desviación estándar:", temp_desviacion, "°C\n")
```

Supongamos que tenemos un conjunto de temperaturas de incubación de diferentes muestras bacterianas, y queremos identificar las muestras que están dentro de un rango de temperatura óptimo para el crecimiento bacteriano (entre 25°C y 37°C).

```{r}
# Vectores con nombre: Muestras y Temperaturas
muestras <- c("Muestra1", "Muestra2", "Muestra3", "Muestra4")
temperaturas <- c(Muestra1 = 37, Muestra2 = 25, Muestra3 = 30, Muestra4 = 40)

# Filtrado de temperaturas dentro del rango óptimo
temperaturas_optimas <- temperaturas[temperaturas >= 25 & temperaturas <= 37]

# Muestras dentro del rango óptimo
muestras_optimas <- names(temperaturas_optimas)

cat("Muestras con temperatura óptima:", muestras_optimas, "\n")
```



**Ejercicio** 
1. Lee la ayuda de `as.factor` para determinar cómo crear un factor "ordenado"
2. Crea un vector con los meses en los que todas las alumnas del grupo cumplen años.
3. Aprovecha los levels para generar un objeto que guarde el número de estudiantes que cumplen años cada mes.




**Ejercicios**

1. Genera un vector con el nombre de 10 virus
2. Asocia esos nombres con su número de acceso en NCBI
3. Genera otro vector que contega los tamaños en pb y los nombres
4. Determina cuáles son mayores de 300 bp
5. Asocia un subconjunto de vectores que sean mayores (menores a 300 bp) y mayores (mayores a 300 bp)
6. Haz un histograma con los tamaños de todos
7. Dibuja un boxplot con los tamaños de todos.Pon en el eje los nombres de todos.



**Ejercicios adicionales **

1. Crea un vector llamado "v1" con los números 2, 4, 6, 8 y 10.
2. Crea un vector llamado "v2" con los números 1, 3, 5, 7 y 9.
3. Suma los vectores "v1" y "v2" elemento por elemento.
4. Multiplica el vector "v1" por el escalar 3.
5. Calcula la media del vector "v2".
6. Encuentra el valor mínimo del vector "v1".
7. Crea un vector llamado "v3" con los números 2, 4, 6, 8 y 10.
8. Compara los vectores "v1" y "v3" y determina si son iguales.
9. Crea un vector "v4" con los primeros 10 números impares.
10. Encuentra los elementos comunes entre los vectores "v2" y "v4"
11. Crea un vector llamado "v1" con números aleatorios enteros entre 1 y 50.
12. Ordena el vector "v1" de forma descendente.
13. Encuentra la mediana del vector "v1".
14. Crea un vector llamado "v2" con números aleatorios enteros entre 10 y 20, de longitud 5.
15 .Calcula el producto punto entre "v1" y "v2".
16 .Crea un vector llamado "v3" con números aleatorios entre 0 y 1, de longitud 10.
17. Normaliza el vector "v3".


<!--chapter:end:02-Vectors.Rmd-->

# Matrices
Una matriz es un arreglo rectangular de datos del mismo tipo. **Solo del mismo tipo**. Está compuesta tanto de columnas como de renglones. 

## Creación de matrices
Para crear una matriz podemos usar la función `matrix()`. Dicha función requiere de, al menos, un vector e indicar al menos una dimensión.

Ejemplo: 
```{r}
y <- matrix(c(1,5,8,-4), nrow=2, ncol=2) #nrow: indica el número de renglones & ncol: indica el número de columnas. 
y
```
Por default, la matriz va agregando los datos por columnas. 



```{r}
z <- matrix(c(TRUE, FALSE,rep(c(TRUE, FALSE),3)),nrow=4)
z
```
¿Por qué sólo es necesario indicar una dimensión (renglones)?


También se puede indicar que se cambien el orden de llenado de la matriz, es decir, en lugar de que lo haga por columnas, lo haga por renglones. 

```{r}
m <- matrix(c(1,2,3,4,5,6),nrow=2,byrow=TRUE)
m
```



 
## Dimensiones de un matriz
La dimensión de una matriz es el número de renglones y de columnas respectivamente. Se puede obtener usando la función `dim()` de *dimensión*. 
**NOTA** 
`dim()` no se puede emplear en elementos unidemsionales (Ej: vectores)

```{r}
dim(y)
dim(z)
```

Así una matriz se distingue de un vector ya que tiene, además de renglones, columnas. 

![Escalar, vector y matriz](Escalar_Vector_Matriz.jpeg)
## Elementos de una matriz 

Para acceder a elementos de un objeto con *indices* (componentes que tienen una posición asignada), debemos usar *corchetes* `[]`. En el caso de la matriz se debe indicar la posición de ambas dimensiones `[renglón,columna]`.

Ejemplo: En este caso se desea seleccionar el elemento del primer renglón, segunda columna.

```{r}
y[1,2]
```
Ejemplo: En este caso se quiere seleccionar todos los elementos del primer renglón. 

```{r}
y[1,]
```

Ejemplo: En este caso se quiere seleccionar todos los elementos de la segunda columna. 

```{r}
y[,2]
```

## Creación de matriz "vacia"
Una forma **mucho menos eficiente** de definir una matriz es declarando una matriz sin elementos (matriz vacía) y después llenándolos de forma explícita asignando un valor distinto a cada posición. 

```{r}
 y <- matrix(nrow=2,ncol=2)
y[1,1] <- "Esta"
y[2,1] <- "es"
y[1,2] <- "una"
y[2,2] <- "matriz"
y
```


## Operaciones rbind y cbind en R para Matrices

En R, las funciones `rbind()` y `cbind()` se utilizan para unir matrices por filas y columnas, respectivamente. Además, la función `t()` se utiliza para transponer una matriz.

## Uso de `rbind()` para unir matrices por filas

La función `rbind()` se utiliza para unir matrices por filas. Por ejemplo, considera las siguientes dos matrices:

```{r}
# Matrices de ejemplo
matriz1 <- matrix(1:6, nrow = 2)
matriz2 <- matrix(7:12, nrow = 2)

# Unir matrices por filas
matriz_unida <- rbind(matriz1, matriz2)
matriz_unida
```
## Uso de cbind() para unir matrices por columnas

La función cbind() se utiliza para unir matrices por columnas. A continuación, se muestra un ejemplo de cómo unir dos matrices por columnas:

```{r}
# Unir matrices por columnas
matriz_unida_columnas <- cbind(matriz1, matriz2)
matriz_unida_columnas
```


**Ejercicio** 

¿Cómo se llenaría una matriz vacia a partir de vectores?
¿El vector tendría que tener la misma longitud que la columna o el renglón de la matriz? 
¿Qué pasaría si la longitud del vector es diferente a la columna o renglón de la matriz? 
¿Cómo podrías emplear `cbind()` & `rbind()`?`
 
## Operaciones con matrices

### Multiplicación de un escalar con una matriz


```{r}
3*m
```

### Suma de dos matrices

```{r}
m + m
n<-matrix(c(2,3,4,5,6,7),ncol=3)
m+n
```

Para sumar matrices deben tener las mismas dimensiones

```{r}
dim(n)
dim(m)
(dim(n)-dim(m))==0
```

### Multiplicación de matrices

Se utiliza el operador `%*%`. Sí. Son tres caracteres. E incluyen dos `%`.
No hay espacios y es un sólo operador .

```{r}
n<-matrix(c(2,3,4,5,6,7),ncol=2)
n
m %*% n 
```

¿Recuerdas cuál es el criterio para calcular el producto de matrices?
¿Recuerdas cómo se multiplican dos matrices?

## Uso de la función `t()` para transponer una matriz

La función `t()` se utiliza para transponer una matriz, es decir, intercambiar filas por columnas y viceversa. Veamos un ejemplo:

```{r}
# Transponer una matriz
matriz_transpuesta <- t(matriz_unida_columnas)
matriz_transpuesta
```

## Seleccionar elementos de matrices

Para seleccionar elementos de matrices se hace de forma análoga a vectores, es decir, se utiliza el operador `[]`. Sólo que esta vez hay que indicar tanto los renglones como la columna en ese orden

```{r}
m[2,3]  # Este es el segundo renglón tercera columna de m
n[3,2]  # Este es el elemento que está en el renglón 3 y columna 2 de la matriz n 
```

### Seleccionar todo(a) un(a) renglón(columna)

Para seleccionar todos los elementos de un renglón dado se utiliza la siguiente sintáxis

```{r}
m[2,]  # Todos los elementos que están en el segundo renglón
```

Para una columna 

```{r}
m[,3] # Toda la tercera columna
```

### Selecccionar elementos de una matriz

¿Qué hace lo siguiente?

```{r}
m[1:2,1]
m[1:2,2:3]
m[-1,]
m[-1,-c(1,3)]
```


## Nombres a renglones y columnas

Al igual que con vectores le podemos poner nombres tanto a renglones como a columnas para ello utilizamos `rownames()` y `colnames()`

```{r}
m   # No tengo nombres :(
```



```{r}
colnames(m)<-LETTERS[1:3]
rownames(m)<-letters[5:6]
```

```{r}
m   # Ahora sí. Feos, pero nombres :) :)
m["e","C"]
m["e","C"]==m[1,3]
```

### Ejercicios

1. Genera dos matrices aleatorias de tamaño 3x3 y luego suma ambas matrices.

2. Crea dos matrices aleatorias, una de tamaño 2x3 y otra de tamaño 3x4. Luego, calcula su producto matricial.

3. Crea una matriz aleatoria de tamaño 4x3 y encuentra su matriz transpuesta.

4. Genera una matriz cuadrada aleatoria de tamaño 4x4 y calcula su determinante.

5. Crea una matriz cuadrada aleatoria de tamaño 3x3 y encuentra su inversa.

6. Genera una matriz aleatoria de tamaño 5x5 y extrae la tercera fila y la segunda columna.

7. Crea una matriz diagonal aleatoria de tamaño 4x4 y encuentra sus elementos diagonales.

8. Define una matriz de coeficientes A y un vector de términos constantes b. Luego, resuelve el sistema de ecuaciones lineales Ax = b.

9. Genera una matriz aleatoria de tamaño 3x3 y multiplica cada uno de sus elementos por un escalar, por ejemplo, 2.

10. Crea una matriz simétrica aleatoria de tamaño 4x4 y verifica si es simétrica.



<!--chapter:end:03-Matrices.Rmd-->

# Data Frames


Un Dataframe en R es una estructura de datos rectangular que se compone de filas y columnas, donde cada columna puede tener un tipo de datos diferente. Los Dataframes son una de las estructuras de datos más utilizadas en R, ya que son la forma estándar de almacenar datos tabulares.

## Crear un Dataframe en R
Podemos crear un DataFrame en R utilizando la función `data.frame()`. Aquí hay un ejemplo de cómo crear un DataFrame simple con datos de estudiantes:

```{r}
# Crear un DataFrame de estudiantes
estudiantes <- data.frame(
  nombre = c("Juan", "María", "Pedro", "Laura"),
  edad = c(20, 22, 21, 23),
  puntaje = c(85, 90, 88, 92)
)

# Ver el DataFrame
print(estudiantes)
```


Para crear un Dataframe en R, puedes utilizar la función `data.frame()`. 
Por ejemplo, para crear un Dataframe con información del genoma de algunos microorganismos, podrías escribir lo siguiente:

```{r}
dna_data <- data.frame(
  secuencia = c("ATCGATCG", "GCTAGCTA", "TTAAGGCT"),
  tamaño = c(8, 8, 8),
  contenido_GC = c(0.5, 0.4, 0.3)
)

print(dna_data)
```
**NOTA** También puedes emplear `View()` para visualizar el DataFrame. 
```{r}
View(dna_data)
```

En este ejemplo, el dataframe tiene tres columnas: "secuencia", "tamaño" y "contenido_GC". La columna "secuencia" contiene cadenas de caracteres (strings) que representan las bases del ADN, mientras que las otras dos columnas contienen valores numéricos.

## Acceder a los datos de un dataframe

Para seleccionar elementos o acceder a algún dato de un dataframe, se hace de forma análoga a las matrices, es decir, se utiliza el operador de subíndice `[]`. 

Por ejemplo, para acceder a la segunda fila de la columna "secuencia" en el Dataframe "dna_data", se puede escribir lo siguiente:

```{r}
dna_data[2, "secuencia"]

```

Esto devolvería la cadena de caracteres "GCTAGCTA".

También puedes acceder a varias filas o columnas a la vez.
Por ejemplo, para acceder a las primeras dos filas de las columnas "tamaño" y "contenido_GC" en el Dataframe "dna_data", podrías escribir lo siguiente:

```{r}
dna_data[1:2, c("tamaño", "contenido_GC")]
```

Esto devolvería un Dataframe con dos filas y dos columnas.

## Agregar y eliminar filas y columnas en un Dataframe en R
Para agregar una nueva columna a un Dataframe en R, puedes utilizar el operador de asignación `<-`. 
Por ejemplo, para agregar una columna que represente la Temperatura de Melting (o Fusión) en el Dataframe "dna_data", podrías escribir lo siguiente:

```{r}
dna_data$temperatura_melting <- c(24, 24, 20)
```

Esto crearía una nueva columna llamada "temperatura_melting" en el Dataframe "dna_data" y la inicializaría con los valores proporcionados.

Para eliminar una columna de un Dataframe en R, puedes utilizar el operador de subíndice`[]` con un valor nulo para la columna que deseas eliminar. Por ejemplo, para eliminar la columna "temperatura_melting" del Dataframe "dna_data", podrías escribir lo siguiente:


```{r}
dna_data$temperatura_melting <- NULL
```

Para agregar una nueva fila a un Dataframe en R, puedes utilizar la función `rbind()`. ¿También se puede aplicar `cbind()` en Dataframe?

**Ejercicio** 
Empleando la siguiente fórmula para calcular la Temperatura de Fusión:  `Tm=4(G+C)+2(A+T)`, diseña una secuencia que cumpla con una Tm de 55°. Agrega sus características (secuencia, tamaño, cantidad GC & Tm) en una nueva fila. También será necesario agregar la columna Tm para indicar la Temperatura de Fusión de cada secuencia. Usa el Dataframe `dna_data` como base. 

### Importar un archivo csv en R

Un archivo csv (Comma Separated Values) es un archivo de texto que contiene datos en formato tabular, donde cada fila representa un registro y cada columna representa una variable. Para importar un archivo CSV en R, puedes utilizar la función `read.csv()`. Por ejemplo, si tienes un archivo llamado "ventas.csv" en tu directorio de trabajo actual, puedes importarlo de la siguiente manera:

```{r}
#ventas <- read.csv("ventas.csv")
```

Esto creará un Dataframe llamado "ventas" en R, que contendrá los datos del archivo CSV.

Si el archivo CSV utiliza un separador de campos diferente a la coma, puedes utilizar la función read.csv2() en su lugar. Por ejemplo, si el archivo CSV utiliza un punto y coma como separador de campos, puedes importarlo de la siguiente manera:

```{r}
#ventas <- read.csv2("ventas.csv")
```
### Importar un archivo TSV en R

Un archivo TSV (Tab Separated Values) es similar a un archivo CSV, pero utiliza **tabulaciones** en lugar de comas para separar los campos. Para importar un archivo TSV en R, puedes utilizar la función read.delim(). Por ejemplo, si tienes un archivo llamado "ventas.tsv" en tu directorio de trabajo actual, puedes importarlo de la siguiente manera:
```{r}
#ventas <- read.delim("ventas.tsv")

```


Esto creará un Dataframe llamado "ventas" en R, que contendrá los datos del archivo TSV.

Si el archivo TSV utiliza un separador de campos diferente a la tabulación, puedes utilizar la función `read.delim2()` en su lugar.

### Importar un archivo Excel en R
Un archivo de Excel es un formato de archivo popular para almacenar datos en formato tabular. Para importar un archivo de Excel en R, puedes utilizar la función readxl::read_excel() del paquete "readxl". Por ejemplo, si tienes un archivo llamado "ventas.xlsx" en tu directorio de trabajo actual, puedes importarlo de la siguiente manera:

```{r}
library(readxl)
#ventas <- read_excel("ventas.xlsx")

```



<!--chapter:end:04-Data_Frames.Rmd-->

---
output:
  word_document: default
  html_document: default
---
# Listas {#Listas}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Las listas son una estructura de datos muy versátil en R, que permiten almacenar una colección de elementos. A diferencia de los vectores, una lista puede contener elementos de diferentes tipos, como números, cadenas y hasta otras listas.

En R, las listas pueden contener una amplia variedad de tipos de datos, incluyendo números, vectores, matrices, y data frames. Esto las hace extremadamente versátiles para la gestión de datos complejos.

**Ejemplos**

- Creación de una Lista

```{r}
# Creando una lista con diferentes tipos de datos
compleja_lista <- list(
  numero = 42,
  vector = c(1, 2, 3),
  matriz = matrix(c(1, 2, 3, 4), nrow = 2),
  data_frame = data.frame(nombre = c("E. coli", "S. aureus"), gram = c("+", "-"))
)

print(compleja_lista)

```



Para acceder a los elementos de una lista, puedes usar el doble corchete [[ ]] o el operador de dólar $. El doble corchete es útil para acceder a los elementos por su índice, mientras que el operador de dólar se usa con nombres.

Accceso por índice

```{r}
# Accediendo al vector dentro de la lista
vector_en_lista <- compleja_lista[[2]]
print(vector_en_lista)

```

### Acceso por Nombre

```{r}
# Accediendo al data frame por nombre
data_frame_en_lista <- compleja_lista$data_frame
print(data_frame_en_lista)

```
## Ejercicios
### Ejercicios Propuestos con listas 

1. 
Crea una lista que contenga al menos cuatro tipos diferentes de datos (incluyendo al menos un vector, una matriz, y un data frame). Luego, escribe código para acceder a cada uno de estos elementos por su índice.

2. 
Añade un nuevo elemento a la compleja_lista que sea otra lista conteniendo información relevante a un experimento microbiológico (p.ej., fechas, resultados de crecimiento, tipo de medio de cultivo). Accede a un elemento específico dentro de esta lista anidada.

Recuerda, el uso efectivo de listas en R puede ayudarte a gestionar y manipular una amplia gama de conjuntos de datos complejos, especialmente útil en campos como la Microbiología.

<!--chapter:end:05-Listas.Rmd-->

---
output:
  word_document: default
  html_document: default
---
# Estructuras de selección {#Estructuras_de_seleccion}

1.  `if`
2.  `if` ... `else`
3.  `ifelse`
4.  `if ... else if ...else if ...else`

## If (si condicional)

La instrucción `if` nos permite probar una condición y esa condición debe arrojar un valor booleano, es decir, un valor de verdad (`TRUE` o `FALSE`) Si la condición es verdadera se ejecuta lo que está dentro de los corchetes, de lo contrario, ejecuta lo que sigue después del corchete de cierre.

**Definición**: Lo que se encuentra dentra del corchete se llama cuerpo ( *body* ) de la declaración `if`

![Diagrama de flujo del If](If_R.001.jpeg){#id .class width=100% height=100%}

La sintaxis de una condición `if` consiste en lo siguiente:

`if (condicion){`

`si la condicion es verdadera`

`Ejecuta TODO lo que está en los corchetes`

`}`

### Sintaxis

``` {.R}
if(<condition>) {
        ## Hace algo
} 
## Continúa con el resto del código
```

### Errores comunes en el `if`

1.  No incializar la variable de la condición.
2.  La condición no arroja un valor de verdad.
3.  No poner todo lo que quieres que haga **dentro** de los corchetes.
4.  Este no es un error, es más bien una advertencia, si la condición arroja un sólo valor de verdad sólo toma en cuenta el primero de ellos.

###Ejemplos de uso del `if`

```{r}

mayor_de_edad<-18

edad<-20

if(edad >=mayor_de_edad){
  print("Eres mayor de edad")
}
x<-5+4
print(x)
```

```{r}
minimo<-20000
dinero<-15000

if(dinero>=minimo){
  print("¿Cómo está Cancún?")
  print("La vida es buena")
  sobrante<-dinero-minimo
  print(paste("Me queda $", sobrante))
}
print("Acá sigue")
```

#### Ejercicios

1.  Elabora un programa que compare tu estatura con tu ídolx y determine si eres más altx.
2.  Toma dos archivos fasta de virus distintos. Leelos con Biostrings y compara sus tamaños ( en bp) y determina si el primero es más grande que el segundo.
3.  A partir del archivo de anotación del genoma de un organismo determina toma dos proteínas al azar y compara sus tamaños. Toma todos los genes de la cadena positiva y todos los de la negativa compara sus tamaños promedio y determina cuál de estos es más grande.

------------------------------------------------------------------------

## Combinación de operadores booleanos

Los operadores lógicos o booleanos se pueden combinar para formar enunciados complejos por ejemplo:

1.  Tengo vacaciones (del trabajo y/o la escuela)
2.  Tengo dinero

Si las dos condiciones son ciertas entonces puedo hacer algo

También podría ser que basta con que una de ellas sea cierta para que haga algo.

### And (&)

El operador booleano `&` representa el y lógico. Estos operadores binarios nos sirven para unir al menos dos enunciados que tienen valor de verdadero o falso (Tengo dinero (V/F), Tengo vacaciones (V/F))

Con estas dos operaciones puedo unirlas utilizando el operador `y` lógico (AND (`&`) representado en R con el símbolo del ampersand (`&`)

Tengo dinero AND Tengo vaciones

Para saber el valor booleano (V/F) del enunciado anterior debemos concocer los valores de verdad de los enunciados por separado

Por ejemplo, podemos representar al primer enunciado por `p` y al segundo enunciado por `q`

`p: Tengo dinero`

`q: Tengo vacaciones`

Para saber cuál es el valor de verdad del enunciado compuesto debemos ver cuáles son todas las combinaciones de valores de verdad de los enunciados que la componen: p verdadero y q verdadero, p falso y q verdadero, p falso y q verdadero, p falso y q falso. Eso se resumen en las tablas de verdad de los operadores

|  p  |  q  | p & q |
|:---:|:---:|:-----:|
|  V  |  V  |   V   |
|  V  |  F  |   F   |
|  F  |  V  |   F   |
|  F  |  F  |   F   |

: Tabla de verdad del AND

Es decir, el `&` solo es **verdadero** cuando ambas condciones son **verdaderas**.

Esto representa lo que se observa en la realidad: es decir, solo hago algo si tengo y tengo vacaciones. Si una de ellas no se cumple (es decir, es falsa) entonces no se lleva a cabo la acción.

### OR (\|)

El operador booleano `|` representa el `o` lógico. Estos operadores binarios nos sirven para unir al menos dos enunciados que tienen valor de verdadero o falso (Tengo dinero (V/F), Tengo vacaciones (V/F))

Con estas dos operaciones puedo unirlas utilizando el operador `y` lógico (OR (`|`) representado en R con el símbolo de *la barrita* (`|`)

Tengo dinero OR Tengo vaciones

Para saber el valor booleano (V/F) del enunciado anterior debemos concocer los valores de verdad de los enunciados por separado

Por ejmplo podemos representar al primer enunciado por `p` y al segundo enunciado por `q`

`p: Tengo dinero`

`q: Tengo vacaciones`

Para saber cuál es el valor de verdad del enunciado compuesto debemos ver cuáles son todas las combinaciones de valores de verdad de los enunciados que la componen: p verdadero y q verdadero, p falso y q verdadero, p falso y q verdadero, p falso y q falso. Eso se resumen en las tablas de verdad de los operadores

|  p  |  q  | p \| q |
|:---:|:---:|:------:|
|  V  |  V  |   V    |
|  V  |  F  |   V    |
|  F  |  V  |   V    |
|  F  |  F  |   F    |

: Tabla de verdad del operador OR

Es decir haría algo, por ejemplo, irme a la playa cuando **al menos** una condición se cumpla. Por ejemplo que tenga dinero aunque no tenga vacaciones, que tenga vacaciones aunque no tenga dinero y, obviamente, también cuando las dos se cumplen.

Es decir, el `|` solo es **falso** cuando ambas condiciones son **falsas**.

### Ejemplos de combinaciones

Por eejmplo es útil para intervalos

$$
18 \leq edad \leq 29 
$$

Esta condición la podemos expresar mediante la combinación de dos: la edad debe ser mayor igual a 18 y (**AND**, `&`) la edad debe ser menor o igual que 29

```{r}

if (edad >= 18 & edad <=29){
  print("Te toca vacunarte")
}

```

**Pregunta**: ¿qué pasaría si se pone un **OR** como unión entre las dos condiciones

```{r}
if (edad >= 18 | edad <=29){
  print("Te toca vacunarte")
}


```

o así (¿es lo mismo?)

```{r}
if (edad <= 29 | edad >= 18){
  print("Te toca vacunarte")
}


```

## Ejercicio

1.  ¿Cómo harías una condición que considere que te gusta el mole y el pozole?

2.  ¿Cómo harías una condición que considere que te gusta el mole o el pozole?

## If ... else (si ... de otro modo)

Si además quieres que se ejecute algo cuando la condición es **falsa** entonces debes usar la declaración `if … else`

``` {.R}
if (condición) { # Si la condición es cierta
hace esto
y esto
y esto
} else { # De otro modo, es decir si es falsa hace lo que #está en el corchete
entonces hace esto otro
y esto otro
y esto
}
```

![Diagrama_if_else](If_else.001.jpeg){#id .class width=100% height=100%}

```{r}
minimo<-20000
vacaciones<-"SI"
dinero<-21000
if(dinero>=minimo & vacaciones=="SI"){
  print("Me voy a la playa, looser")
}else{
  print("Me quedo en mi casa")
}

```

## ifelse

Si la condición es muy simple ,tanto para cuando es verdadero como cuando es falso se puede implementar la función `ifelse` en una línea. Es equivalente a la condición compuesta pero ahorramos código.

```{r}
edad<-21
ifelse(edad>=18, "Ya eres grande","Todavia no puedes beber (legalmente)")

edad<-12
ifelse(edad>=18, "Ya eres grande","Todavia no puedes beber (legalmente)")


```

## If ... else if ... else ( si, si no si , si no si, si no)

Si tienes más opciones, es decir no alternativas, puedes usar la sentencia `if … else if …else if …else`

Importante

:   Esta estructura se ejecuta solo en la primera que sea verdadera o si no hay una verdadera ejecuta lo que esta en el `else`

``` {.R}
if ( condicion 1) {
Hace cosas
} else if ( condcion 2) {
Hace otras cosas
} else if ( condicion 3) {
Hace estas otras cosas
} else {
No le queda de otra y hace esto
}
```

![Diagrama de flujo del if... else if... else if...else](If_else_else_if.001.jpeg){#id .class width=100% height=150%}
```{r}
numero<-3
if(numero > 0){
  print("Tu número es positivo")
}else if (numero <0){
  print("Tu número es negativo")
}else{
  print("Tu número es cero")
}


numero<- -27
if(numero > 0){
  print("Tu número es positivo")
}else if (numero <0){
  print("Tu número es negativo")
}else{
  print("Tu número es cero")
}


numero<- 0
if(numero > 0){
  print("Tu número es positivo")
}else if (numero <0){
  print("Tu número es negativo")
}else{
  print("Tu número es cero")
}

```

**Pregunta**: ¿por qué no es necesario poner un if en el último else?

## Ejercicios

1.  Elabora un programa que con tu fecha de cumpleaños te diga en qué estación del año naciste.

2.  Elabora un porgrama que a partir de las calficaciones de tus examenes parciales y 8 quincenales arroje si exentaras o no este curso usando los criterios definidos en el programa del curso. Asume que en las tareas y demás actividades tienes 10.

<!--chapter:end:06-Estructuras_de_seleccion.Rmd-->

------------------------------------------------------------------------

------------------------------------------------------------------------

# Funciones en R {#functions}

Las funciones definidas por el usuario en R son bloques de código que realizan una tarea específica y se pueden llamar desde cualquier lugar del programa. Las funciones en R se definen usando la palabra clave function seguida del nombre de la función, paréntesis y llaves.

Las funciones toman argumentos de entrada y producen un resultado como salida. Las funciones definidas por el usuario son una herramienta poderosa en R que permiten reutilizar código y automatizar tareas. Una vez que domines la sintaxis básica de la función en R, puedes comenzar a crear funciones más avanzadas y complejas para adaptarse a tus necesidades.

## Sintaxis básica de una función en R

La sintaxis básica para definir una función en R es la siguiente:

```{r}
nombre_de_la_funcion <- function(arg1, arg2, ...) {
  # Cuerpo de la función
  resultado <- ...
  return(resultado)
}

```

Donde:

-   `nombre_de_la_funcion`: el nombre que le das a tu función. -`function`: la palabra *function*
-   `arg1`, `arg2`, ...: los argumentos de entrada que toma la función (opcional).
-   `resultado`: el resultado que devuelve la función (opcional).

El cuerpo de la función es donde se escribe el código que realiza la tarea específica. El resultado de la función se devuelve con la función `return()`.

## Ejemplo de función definida por el usuario en R

Aquí hay un ejemplo de una función definida por el usuario que toma dos argumentos x e y y devuelve la suma de ambos:

```{r}
mi_suma <- function(x, y) {
  resultado <- x + y
  return(resultado)
}

```

Para usar esta función, simplemente llámala con los argumentos que deseas pasar:

```{r}
mi_suma(3, 5)

```

## Ejemplo de función con argumentos por defecto en R

Las funciones en R también pueden tener argumentos por defecto que se utilizan si no se proporciona ningún valor para ellos. Aquí hay un ejemplo de una función que tiene dos argumentos, `x` e `y`, y `y` tiene un valor por defecto de 2:

```{r}
mi_funcion <- function(x, y = 2) {
  resultado <- x * y
  return(resultado)
}
```

En este caso, si no se proporciona un valor para `y`, se utilizará el valor por defecto de `2`:

```{r}
mi_funcion(3)
```

También puede proporcionar un valor diferente para y, si es necesario:

```{r}
mi_funcion(3, 5)
```

## Definir una función con un parámetro opcional

```{r}
saludar <- function(nombre, saludo = "Hola") {
  mensaje <- paste(saludo, nombre)
  return(mensaje)
}
```

### Llamar a la función saludar sin proporcionar el parámetro opcional

```{r}
mensaje1 <- saludar("Juan")
print(mensaje1)
```

### Llamar a la función saludar proporcionando el parámetro opcional

```{r}
mensaje2 <- saludar("María", "Buenos días")
print(mensaje2)
```

## Definir una función para calcular el área de un círculo

```{r}
area_circulo <- function(radio) {
  area <- pi * radio^2
  return(area)
}
# Ejemplo de uso

radio <- 3
area <- area_circulo(radio)
print(paste("El área del círculo con radio", radio, "es:", area))
```

## Definir una función para calcular el factorial de un número

```{r}
factorial <- function(n) {
  if (n == 0) {
    return(1)
  } else {
    return(n * factorial(n - 1))
  }
}

# Ejemplo de uso
numero <- 5
resultado <- factorial(numero)
print(paste("El factorial de", numero, "es:", resultado))
```

## Definir una función para verificar si un número es primo

```{r}
es_primo <- function(n) {
  if (n <= 1) {
    return(FALSE)
  } else if (n <= 3) {
    return(TRUE)
  } else if (n %% 2 == 0 | n %% 3 == 0) {
    return(FALSE)
  }
  i <- 5
  while (i * i <= n) {
    if (n %% i == 0 | n %% (i + 2) == 0) {
      return(FALSE)
    }
    i <- i + 6
  }
  return(TRUE)
}

# Ejemplo de uso
numero <- 11
if (es_primo(numero)) {
  print(paste(numero, "es un número primo."))
} else {
  print(paste(numero, "no es un número primo."))
}
```

**Ejercicios**

1.  Escribe una función que tome un vector numérico como argumento de entrada y devuelva la media aritmética de los valores.

2.  Escribe una función que tome dos vectores numéricos como argumentos de entrada y devuelva su producto punto (también conocido como producto escalar).

3.  Escribe una función que tome un vector numérico como argumento de entrada y devuelva el valor mínimo y máximo en una lista.

4.  Escribe una función que tome una matriz cuadrada como argumento de entrada y devuelva su determinante.

5.  Escribe una función que tome una matriz de $2 \times 2$ como argumento de entrada y devuelva su transpuesta.

6.  Escribe una función que tome una lista como argumento de entrada y devuelva la longitud de cada elemento en una lista.

7.  Escribe una función que tome una cadena de texto como argumento de entrada y devuelva una lista con todas las palabras en la cadena.

8.  Escribe una función que tome un vector numérico como argumento de entrada y devuelva un vector con los valores ordenados de menor a mayor.

9.  Escribe una función que tome un vector de caracteres como argumento de entrada y devuelva un vector con los mismos elementos en orden inverso.

10. Escribe una función que tome una matriz como argumento de entrada y devuelva la diagonal principal en un vector.

<!--chapter:end:07-Funciones.Rmd-->

---
---

# RProjects {#rprojects}



Los proyectos en R (R Projects) son una manera eficiente de organizar y gestionar todo el trabajo relacionado con tus análisis en R. Facilitan la colaboración, el control de versiones y la reproducibilidad de tu investigación o análisis de datos.

## Introducción a R Projects en RStudio

RStudio permite crear proyectos, que son básicamente carpetas que contienen todos los archivos relacionados con un análisis específico. Al trabajar dentro de un proyecto, RStudio automáticamente establece el directorio del proyecto como el directorio de trabajo, simplificando la gestión de archivos y el flujo de trabajo.

**Crear un nuevo proyecto:**

1. En RStudio, ve a `File > New Project`.
2. Elige crear un proyecto en un nuevo directorio o en un directorio existente.
3. Asigna un nombre al proyecto y selecciona la ubicación para el directorio del proyecto.
4. Haz clic en `Create Project`.

## Gestión de proyectos: organización y buenas prácticas

Una buena gestión de proyectos en R implica una estructura de carpetas organizada, nomenclatura consistente de archivos y un entendimiento claro del flujo de trabajo del proyecto.

**Estructura de carpetas recomendada:**

- `/01_RawData`: Guarda tus bases de datos originales (preferentemente en formato de solo lectura como .csv o .xlsx)..
- `/02_Scripts`: Guardar tus scripts con extensiones .R o .Rmd 
- `/03_ProceesedData`: Almacena archivos de salida procesados, como datos limpios o tablas resumen
- `/04_output`: .Guarda las figuras generadas por tus scripts.

**Buenas prácticas:**

- Mantén un script de R (por ejemplo, `main.R`) que sirva como punto de entrada para entender y ejecutar el proyecto.
- Documenta tus scripts detalladamente para que otros (o tú en el futuro) puedan entender el propósito y funcionamiento de tu código.
- Utiliza nombres de archivos y variables claros y descriptivos.

## Colaboración y control de versiones con Git y GitHub

El control de versiones es crucial para la colaboración en proyectos de programación. Git, integrado con GitHub, permite a múltiples personas trabajar en el mismo proyecto sin conflictos.

**Configurar Git en RStudio:**

1. Instala Git en tu computadora y configúralo con tus credenciales de GitHub.
2. En RStudio, ve a `Tools > Global Options > Git/SVN` para configurar tu cuenta de Git.
3. Crea un nuevo repositorio en GitHub y clónalo en tu computadora a través de la URL del repositorio.

**Uso básico de Git con RStudio:**

- **Commit**: Guarda los cambios realizados en tus archivos al repositorio local. Describe brevemente los cambios realizados.
- **Push**: Envía tus commits locales a GitHub para actualizar el repositorio remoto.
- **Pull**: Actualiza tu repositorio local con los cambios realizados por otros colaboradores en el repositorio remoto.

**Colaborar en proyectos:**

- Utiliza *branches* para trabajar en nuevas características o experimentos sin afectar la rama principal (*main* o *master*).
- Abre *pull requests* para discutir cambios antes de integrarlos a la rama principal.
- Realiza revisiones de código y utiliza *issues* para rastrear tareas y discutir problemas.

<!--chapter:end:08-RProjects.Rmd-->

# Visualización de datos con ggplot2

## Introducción

La visualización de datos es una herramienta poderosa en el análisis de datos, permitiendo comunicar información compleja de manera intuitiva y efectiva. `ggplot2` es un paquete en R que facilita la creación de gráficos de calidad de publicación de manera sencilla. Este documento proporciona una introducción a `ggplot2` y ejercicios para practicar.

## Configuración inicial

Primero, asegúrate de tener instalado `ggplot2`.

```{r}
library(ggplot2)
```

## Creación de un gráfico básico

Vamos a comenzar con un gráfico de dispersión simple utilizando el conjunto de datos mtcars.

```{r}
ggplot(data = mtcars, aes(x = wt, y = mpg)) + 
  geom_point() +
  labs(title = "Consumo de Gasolina vs. Peso",
       x = "Peso (1000 lbs)",
       y = "Millas por Galón (mpg)")

```

## Personalización de gráficos

Ahora, personalizaremos el gráfico cambiando colores y añadiendo una línea de tendencia.

```{r}
ggplot(data = mtcars, aes(x = wt, y = mpg, color = factor(gear))) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Consumo de Gasolina vs. Peso por Tipo de Cambio",
       x = "Peso (1000 lbs)",
       y = "Millas por Galón (mpg)",
       color = "Tipo de Cambio") +
  theme_minimal()

```
### Ejercicios sugeridos

1.  Explora otro conjunto de datos: Utiliza el conjunto de datos iris para crear un gráfico de dispersión que muestre la relación entre Sepal.Length y Sepal.Width. Colorea los puntos según la especie.
2.  Personaliza tu gráfico: Añade títulos personalizados a los ejes y al gráfico. Experimenta con diferentes temas, como theme_bw() o theme_light().
3.  Exploración de geométricas: Utiliza geom_histogram() para crear un histograma del Sepal.Length en el conjunto de datos iris. Ajusta los parámetros binwidth y fill.
4.  Facetas para múltiples gráficos: Utiliza facet_wrap(\~ species) para crear gráficos separados para cada especie en el conjunto de datos iris, mostrando la relación entre Sepal.Length y Sepal.Width.

## Soluciones a los ejercicios sugeridos

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
  geom_point() +
  labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
       x = "Largo del Sépalo",
       y = "Ancho del Sépalo")

```


```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
  geom_point() +
  labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
       x = "Largo del Sépalo",
       y = "Ancho del Sépalo") +
  theme_light() +
  theme(legend.title = element_blank())

```



```{r}
ggplot(data = iris, aes(x = Sepal.Length)) + 
  geom_histogram(binwidth = 0.5, fill = "blue") +
  labs(title = "Distribución del Largo del Sépalo",
       x = "Largo del Sépalo",
       y = "Frecuencia")

```

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) + 
  geom_point() +
  facet_wrap(~ Species) +
  labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
       x = "Largo del Sépalo",
       y = "Ancho del Sépalo")

```

## Ejercicios resueltos

En esta sección usaremos la librería `palmerpenguins`

```{r}
library(palmerpenguins)
library(ggplot2)
```


### Ejercicio 1: Gráfico de dispersión básico
Crea un gráfico de dispersión para visualizar la relación entre la longitud del culmen y la profundidad del culmen de los pingüinos.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point()
```


### Ejercicio 2: Diferenciación por especie
Modifica el gráfico de dispersión anterior para diferenciar los puntos por especie de pingüino.


```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point()

```


### Ejercicio 3: Histograma de masa corporal
Crea un histograma para explorar la distribución de la masa corporal de los pingüinos.

```{r}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(bins = 30)

```

### Ejercicio 4: Barras de error por especie
Genera un gráfico de barras que muestre la masa corporal media de los pingüinos por especie, incluyendo barras de error.

```{r}
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_bar(stat = "summary", fun = "mean") +
  geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2)

```

###Ejercicio 5: Boxplot de profundidad del culmen
Crea un boxplot para comparar la profundidad del culmen entre las diferentes especies de pingüinos.


```{r}
ggplot(penguins, aes(x = species, y = bill_depth_mm)) +
  geom_boxplot()

```

### Ejercicio 6: Facetado por islas
Repite el gráfico de dispersión de longitud vs. profundidad del culmen, pero esta vez facetado por la isla de origen.
```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point() +
  facet_wrap(~island)
```


### Ejercicio 7: Densidad de masa corporal
Muestra la densidad de la distribución de la masa corporal de los pingüinos utilizando un gráfico de densidad.

```{r}
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_density(alpha = 0.7)

```


### Ejercicio 8: Gráfico de violín de la longitud del culmen
Genera un gráfico de violín para visualizar la distribución de la longitud del culmen por especie.

```{r}
ggplot(penguins, aes(x = species, y = bill_length_mm)) +
  geom_violin()

```


### Ejercicio 9: Puntos superpuestos en boxplot
Crea un boxplot de la profundidad del culmen por especie y superpón los puntos de datos individuales.

```{r}
ggplot(penguins, aes(x = species, y = bill_depth_mm)) +
  geom_boxplot(alpha = 0.5) +
  geom_jitter(width = 0.2)

```

### Ejercicio 10: Gráfico de líneas de masa corporal promedio a lo largo del tiempo
Asumiendo que los datos estén ordenados temporalmente, muestra cómo cambia la masa corporal promedio a lo largo del tiempo.

```{r}
# Asumiendo que 'year' representa el tiempo en tus datos
ggplot(penguins, aes(x = year, y = body_mass_g, group = 1)) +
  geom_line(stat = "summary", fun = "mean")
```

### Ejercicio 11: Gráfico de dispersión con tamaño de punto
Modifica el gráfico de dispersión de longitud vs. profundidad del culmen para que el tamaño de los puntos refleje la masa corporal de los pingüinos.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, size = body_mass_g)) +
  geom_point(alpha = 0.5)

```


### Ejercicio 12: Barras apiladas de especies por isla
Crea un gráfico de barras apiladas que muestre la cantidad de pingüinos de cada especie presentes en cada isla.


```{r}
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "stack")

```


### Ejercicio 13: Gráfico de correlación con texto
Genera un gráfico de dispersión entre la longitud y la profundidad del culmen e incluye un texto que muestre el coeficiente de correlación en el gráfico.

```{r}
library(ggpubr)
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point() +
  stat_cor(method = "pearson", label.x = 3, label.y = 50)

```

### Ejercicio 14: Mapa de calor de la longitud y profundidad del culmen
Crea un mapa de calor que muestre la distribución conjunta de la longitud y la profundidad del culmen de los pingüinos.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_bin2d()

```



### Ejercicio 15: Gráfico de interacción entre tres variables
Explora la relación entre la longitud del culmen, la profundidad del culmen y la masa corporal, diferenciando por especie.


```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = body_mass_g)) +
  geom_point() +
  facet_wrap(~species)

```


### Ejercicios propuestos

1. Gráfico de dispersión con facetas por sexo
Crea un gráfico de dispersión para examinar la relación entre la longitud del culmen y la profundidad del culmen, separando los datos por sexo de los pingüinos utilizando facetas.

2. Comparación de masa corporal entre islas
Utiliza un gráfico de barras para comparar la masa corporal media de los pingüinos en las diferentes islas.

3. Gráfico de densidad por sexo
Genera gráficos de densidad para la longitud del culmen, diferenciados por sexo de los pingüinos.

4. Gráfico de líneas de tendencia para la profundidad del culmen
Crea un gráfico que muestre la tendencia de la profundidad del culmen a lo largo del tiempo para cada especie de pingüino.

5. Mapa de calor de la correlación entre variables numéricas
Utiliza funciones de `ggplot2` para crear un mapa de calor que muestre la correlación entre las variables numéricas de los datos de pingüinos.

6. Gráfico de barras de conteo por especie
Crea un gráfico de barras que muestre el número de observaciones (conteo) para cada especie de pingüino.

7. Análisis de outliers en la masa corporal
Utiliza un boxplot para identificar outliers en la masa corporal de los pingüinos y diferencia por especie.

9. Gráfico de dispersión con modelado lineal
Crea un gráfico de dispersión de la longitud vs. profundidad del culmen e incluye una línea de tendencia lineal.

10. Barras apiladas de conteo por isla y especie
Genera un gráfico de barras apiladas que muestre el número de pingüinos de cada especie en cada isla.

11. Gráfico de violín con puntos individuales
Crea gráficos de violín para la masa corporal de los pingüinos por especie e incluye los puntos individuales de los datos.

<!--chapter:end:08-Visualizacion_de_Datos.Rmd-->

# Visualización de datos con ggplot2

## Introducción

La visualización de datos es una herramienta poderosa en el análisis de datos, permitiendo comunicar información compleja de manera intuitiva y efectiva. `ggplot2` es un paquete en R que facilita la creación de gráficos de calidad de publicación de manera sencilla. Este documento proporciona una introducción a `ggplot2` y ejercicios para practicar.

## Configuración inicial

Primero, asegúrate de tener instalado `ggplot2`.

```{r}
library(ggplot2)
```

## Creación de un gráfico básico

Vamos a comenzar con un gráfico de dispersión simple utilizando el conjunto de datos mtcars.

```{r}
ggplot(data = mtcars, aes(x = wt, y = mpg)) + 
  geom_point() +
  labs(title = "Consumo de Gasolina vs. Peso",
       x = "Peso (1000 lbs)",
       y = "Millas por Galón (mpg)")

```

## Personalización de gráficos

Ahora, personalizaremos el gráfico cambiando colores y añadiendo una línea de tendencia.

```{r}
ggplot(data = mtcars, aes(x = wt, y = mpg, color = factor(gear))) + 
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Consumo de Gasolina vs. Peso por Tipo de Cambio",
       x = "Peso (1000 lbs)",
       y = "Millas por Galón (mpg)",
       color = "Tipo de Cambio") +
  theme_minimal()

```
### Ejercicios sugeridos

1.  Explora otro conjunto de datos: Utiliza el conjunto de datos iris para crear un gráfico de dispersión que muestre la relación entre Sepal.Length y Sepal.Width. Colorea los puntos según la especie.
2.  Personaliza tu gráfico: Añade títulos personalizados a los ejes y al gráfico. Experimenta con diferentes temas, como theme_bw() o theme_light().
3.  Exploración de geométricas: Utiliza geom_histogram() para crear un histograma del Sepal.Length en el conjunto de datos iris. Ajusta los parámetros binwidth y fill.
4.  Facetas para múltiples gráficos: Utiliza facet_wrap(\~ species) para crear gráficos separados para cada especie en el conjunto de datos iris, mostrando la relación entre Sepal.Length y Sepal.Width.

## Soluciones a los ejercicios sugeridos

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
  geom_point() +
  labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
       x = "Largo del Sépalo",
       y = "Ancho del Sépalo")

```


```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
  geom_point() +
  labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
       x = "Largo del Sépalo",
       y = "Ancho del Sépalo") +
  theme_light() +
  theme(legend.title = element_blank())

```



```{r}
ggplot(data = iris, aes(x = Sepal.Length)) + 
  geom_histogram(binwidth = 0.5, fill = "blue") +
  labs(title = "Distribución del Largo del Sépalo",
       x = "Largo del Sépalo",
       y = "Frecuencia")

```

```{r}
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) + 
  geom_point() +
  facet_wrap(~ Species) +
  labs(title = "Relación entre el Largo y el Ancho del Sépalo por Especie",
       x = "Largo del Sépalo",
       y = "Ancho del Sépalo")

```

## Ejercicios resueltos

En esta sección usaremos la librería `palmerpenguins`

```{r}
library(palmerpenguins)
library(ggplot2)
```


### Ejercicio 1: Gráfico de dispersión básico
Crea un gráfico de dispersión para visualizar la relación entre la longitud del culmen y la profundidad del culmen de los pingüinos.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point()
```


### Ejercicio 2: Diferenciación por especie
Modifica el gráfico de dispersión anterior para diferenciar los puntos por especie de pingüino.


```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point()

```


### Ejercicio 3: Histograma de masa corporal
Crea un histograma para explorar la distribución de la masa corporal de los pingüinos.

```{r}
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(bins = 30)

```

### Ejercicio 4: Barras de error por especie
Genera un gráfico de barras que muestre la masa corporal media de los pingüinos por especie, incluyendo barras de error.

```{r}
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_bar(stat = "summary", fun = "mean") +
  geom_errorbar(stat = "summary", fun.data = mean_se, width = 0.2)

```

###Ejercicio 5: Boxplot de profundidad del culmen
Crea un boxplot para comparar la profundidad del culmen entre las diferentes especies de pingüinos.


```{r}
ggplot(penguins, aes(x = species, y = bill_depth_mm)) +
  geom_boxplot()

```

### Ejercicio 6: Facetado por islas
Repite el gráfico de dispersión de longitud vs. profundidad del culmen, pero esta vez facetado por la isla de origen.
```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point() +
  facet_wrap(~island)
```


### Ejercicio 7: Densidad de masa corporal
Muestra la densidad de la distribución de la masa corporal de los pingüinos utilizando un gráfico de densidad.

```{r}
ggplot(penguins, aes(x = body_mass_g, fill = species)) +
  geom_density(alpha = 0.7)

```


### Ejercicio 8: Gráfico de violín de la longitud del culmen
Genera un gráfico de violín para visualizar la distribución de la longitud del culmen por especie.

```{r}
ggplot(penguins, aes(x = species, y = bill_length_mm)) +
  geom_violin()

```


### Ejercicio 9: Puntos superpuestos en boxplot
Crea un boxplot de la profundidad del culmen por especie y superpón los puntos de datos individuales.

```{r}
ggplot(penguins, aes(x = species, y = bill_depth_mm)) +
  geom_boxplot(alpha = 0.5) +
  geom_jitter(width = 0.2)

```

### Ejercicio 10: Gráfico de líneas de masa corporal promedio a lo largo del tiempo
Asumiendo que los datos estén ordenados temporalmente, muestra cómo cambia la masa corporal promedio a lo largo del tiempo.

```{r}
# Asumiendo que 'year' representa el tiempo en tus datos
ggplot(penguins, aes(x = year, y = body_mass_g, group = 1)) +
  geom_line(stat = "summary", fun = "mean")
```

### Ejercicio 11: Gráfico de dispersión con tamaño de punto
Modifica el gráfico de dispersión de longitud vs. profundidad del culmen para que el tamaño de los puntos refleje la masa corporal de los pingüinos.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, size = body_mass_g)) +
  geom_point(alpha = 0.5)

```


### Ejercicio 12: Barras apiladas de especies por isla
Crea un gráfico de barras apiladas que muestre la cantidad de pingüinos de cada especie presentes en cada isla.


```{r}
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "stack")

```


### Ejercicio 13: Gráfico de correlación con texto
Genera un gráfico de dispersión entre la longitud y la profundidad del culmen e incluye un texto que muestre el coeficiente de correlación en el gráfico.

```{r}
library(ggpubr)
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point() +
  stat_cor(method = "pearson", label.x = 3, label.y = 50)

```

### Ejercicio 14: Mapa de calor de la longitud y profundidad del culmen
Crea un mapa de calor que muestre la distribución conjunta de la longitud y la profundidad del culmen de los pingüinos.

```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_bin2d()

```



### Ejercicio 15: Gráfico de interacción entre tres variables
Explora la relación entre la longitud del culmen, la profundidad del culmen y la masa corporal, diferenciando por especie.


```{r}
ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = body_mass_g)) +
  geom_point() +
  facet_wrap(~species)

```


### Ejercicios propuestos

1. Gráfico de dispersión con facetas por sexo
Crea un gráfico de dispersión para examinar la relación entre la longitud del culmen y la profundidad del culmen, separando los datos por sexo de los pingüinos utilizando facetas.

2. Comparación de masa corporal entre islas
Utiliza un gráfico de barras para comparar la masa corporal media de los pingüinos en las diferentes islas.

3. Gráfico de densidad por sexo
Genera gráficos de densidad para la longitud del culmen, diferenciados por sexo de los pingüinos.

4. Gráfico de líneas de tendencia para la profundidad del culmen
Crea un gráfico que muestre la tendencia de la profundidad del culmen a lo largo del tiempo para cada especie de pingüino.

5. Mapa de calor de la correlación entre variables numéricas
Utiliza funciones de `ggplot2` para crear un mapa de calor que muestre la correlación entre las variables numéricas de los datos de pingüinos.

6. Gráfico de barras de conteo por especie
Crea un gráfico de barras que muestre el número de observaciones (conteo) para cada especie de pingüino.

7. Análisis de outliers en la masa corporal
Utiliza un boxplot para identificar outliers en la masa corporal de los pingüinos y diferencia por especie.

9. Gráfico de dispersión con modelado lineal
Crea un gráfico de dispersión de la longitud vs. profundidad del culmen e incluye una línea de tendencia lineal.

10. Barras apiladas de conteo por isla y especie
Genera un gráfico de barras apiladas que muestre el número de pingüinos de cada especie en cada isla.

11. Gráfico de violín con puntos individuales
Crea gráficos de violín para la masa corporal de los pingüinos por especie e incluye los puntos individuales de los datos.

<!--chapter:end:09-Visualizacion_de_Datos_con_ggplot2.Rmd-->

---
  nocite: '@*'
  output:
    word_document: default
    html_document: default
    pdf_document: default
---
# Referencias {#referencias}


<!--chapter:end:10_references.Rmd-->

